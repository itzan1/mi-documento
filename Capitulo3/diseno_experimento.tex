
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%           Capítulo 3: Metodologia                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\chapter{Metodología}
En este capítulo se expone todo el desarrollo de la fuente de alto voltaje en cuestión; diseño del sistema, fabricación del sistema, diseño del firmware del micro controlador, implementación y por último el método experimental.\\

El sistema esta compuesto por dos partes, hardware y firmware, el hardware se compone de tres partes como vemos en la figura 3.1: parte digital de control, inversor de voltaje y rectificador multiplicador. \\

Por otro lado el firmware consiste en los programas que realizan el control completo de la generación de alto voltaje por medio del desarrollo de un ambiente gráfico al que el usuario tiene acceso,  control para el senseo de voltajes, corrientes y protecciones necesarias para el correcto funcionamiento del sistema en general, así como también un control para el inversor de voltaje, mediante la implementación de un ADC ( Analog to Digital Converter) a la salida de una devanado de baja en el transformador de alto voltaje el cual controla la salida de alto voltaje. Observemos de manera gráfica la topologia del sistema en la figura 3.1. 
\newpage


 % The \cite command functions as follows:
 %   \citet{key} ==>>                Jones et al. (1990)
 %   \citet*{key} ==>>               Jones, Baker, and Smith (1990)
 %   \citep{key} ==>>                (Jones et al., 1990)
 %   \citep*{key} ==>>               (Jones, Baker, and Smith, 1990)
 %   \citep[chap. 2]{key} ==>>       (Jones et al., 1990, chap. 2)
 %   \citep[e.g.][]{key} ==>>        (e.g. Jones et al., 1990)
 %   \citep[e.g.][p. 32]{key} ==>>   (e.g. Jones et al., p. 32)
 %   \citeauthor{key} ==>>           Jones et al.
 %   \citeauthor*{key} ==>>          Jones, Baker, and Smith
 %   \citeyear{key} ==>>             1990



\section{Materiales utilizados}

La medición y comprobación del alto voltaje no es tan sencilla si no se tienen las herramientas necesarias para ello. La utilización de osciloscopios (figura 3.2), voltimetros (figura 3.3) y sistemas de medición se ve afectado debido a que en su mayoría los voltajes soportados por los equipos son apenas de unos cuantos miles de volts. Es por ello que en este proyecto se han requerido herramientas como lo son las sondas divisoras de voltaje, similar a la que se aprecia en la figura 3.1, permitiendo así la utilización de las herramientas antes comentadas aquí.\\

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{Capitulo3/figs/sonda.png}
\caption{Sonda de alto voltaje}
\end{figure}

Con esta herramienta se ha logrado utilizar el osciloscopio y analizar la señal para presentar resultados mas claros. Podemos observar el osciloscopio utilizado para las mediciones y un multimetro fluke, los cuales son suficientes para determinar la eficiencia de nuestra fuente de voltaje. Teniendo en cuenta siempre la seguridad requerida para la operación de estos instrumentos.


\begin{figure}[H]
\centering
\includegraphics[width=4cm]{Capitulo3/figs/multim.png}
\caption{Multimetro utilizado en experimento}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{Capitulo3/figs/oscilo.png}
\caption{Osciloscopio utilizado en experimento}
\end{figure}

Para la fabricación de los PCB se utilizo una herramienta LPKF, router computarizado. El cual, una vez hecho el diseño en el programa EAGLE se prosiguió a la generación de los archivos gerber para su posterior maquinación. 

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{Capitulo3/figs/proto.png}
\caption{Router CNC}
\end{figure}
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                          Descripción de la planta                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Diseño del hardware}


La figura 3.1 muestra un diagrama a bloques de la estructura general del hardware que conforma el sistema de generación de alto voltaje, el cual esta compuesto, desde la parte superior a la inferior, primeramente por bloques relacionados con el control digital del sistema, este bloque se encarga de las interfaces para el usuario así como también de el control e instrumentación de los diferentes sensores, el siguiente conjunto de bloques representan la electrónica encargada de la inversión de voltaje y por ultimo tenemos la rectificación.  \\

\begin{figure}[H]
\centering
\includegraphics[width=12
cm]{Capitulo3/figs/diagrama.png}
\caption{Topologia de fuente de alto voltaje}
\end{figure}
\newpage
\subsection{Hardware de interface}
Para el desarrollo de la interface gráfica se a utilizado un microcontrolador ATMEGA2560, implementado por la facilidad de programación y los tiempos cortos para la conclusión de este proyecto, así como también la implementación de una pantalla TFT-LCD ( Pantalla de cristal líquido de transistores de película fina) y comunicación UART como interfaces gráfica al usuario. Se ha utilizado el hardware de dicha placa y ahorrado tiempo de desarrollo. \\


\begin{figure}[H]
\centering
\includegraphics[width=9
cm]{Capitulo3/figs/pantalla0.jpg}
\caption{LCD-TFT para interface gráfica}
\end{figure}
\newpage
\subsection{Hardware de fuente de voltaje a 180w}

Esta sección consiste en varias etapas de desarrollo, para ello primero se ha desarrollado una fuente de voltaje de 180W, que es el primer circuito a analizar. Podemos observar en la figura 3.2 el diseño propuesto. El cual esta conformado por el regulador de voltaje LM723 en modalidad fuente de voltaje por modalidad de regulación positiva.\\

Se ha simulado esta fuente de voltaje en el programa LTSPICE como se muestra en la figura 3.4, en este punto se busca el menor riso posible en nuestra salida final, ya que, en este punto el ruido sera amplificado cientos de veces. Podemos observar en la figura 3.5 que nuestra simulación se acerca bastante a lo buscado, una señal de 12v en corriente directa, teniendo una señal estabilizada en un tiempo de 24ms, suficientemente pequeño para la inicialización de nuestro proyecto. El diseño del PCB se encuentra en la figura 3.6, el cual fue diseñado en el programa EAGLE.\\

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{Capitulo3/figs/fuente.png}
\caption{Simulación en LTSPICE fuente 180w}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/SIMFUENTE.png}
\caption{Simulación en LTSPICE fuente 180w}
\end{figure}




\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/12v.png}
\caption{Simulación fuente regulable en LTSPICE}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/pcb.png}
\caption{Diseño placa de fuente de regulable de 180w}
\end{figure}





\newpage

\subsection{Hardware inversor}

Para el inversor se ha implementado una topologia del tipo puente H, ya que es una de las mas utilizadas por los desarrolladores. El integrado BTS7960B es un mosfet de potencia bastante robusto y con una comunidad de desarrollo bastante grande, es por ello que se ha seleccionado este modelo entre los miles que existen en el mercado. Podemos observar el diagrama implementado en la figura 3.7 \cite{ibt} y partiendo de el se ha utilizado la placa de desarrollo IBT2 (figura 3.8) por cuestión de costos. \\

\begin{figure}[H]
\centering
\includegraphics[width=6cm]{Capitulo3/figs/ibt2.png}
\caption{diagrama puente H}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=6cm]{Capitulo3/figs/bts.jpg}
\caption{diagrama puente H}
\end{figure}

\newpage


\subsection{Multiplicador de voltaje Cockroft Walton}
Mediante el motor de simulación de LTSPICE se ha realizado el diseño del multiplicador a utilizar. Contando con valores de capacitores de 0.1 $\mu$-Faradios, diodos MUR4100, voltaje de entrada de 1KV y una frecuencia variable de 10KHZ. Podemos observar en la figura 3.9 el diseño planteado, con la finalidad de tener un punto de referencia al momento de realizar el experimento. \\

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/multi.png}
\caption{Multiplicador de voltaje 2 niveles}
\end{figure}

Se han realizado corridas en el simulador con cargas que exigen 1 mA, 10 mA y pruebas sin carga. Podemos observar en la figura 3.10 la salida de CD que se obtiene cuando no tenemos carga alguna, como vemos la salida esta aparentemente libre de riso y este es el punto de referencia para medir la eficiencia de nuestra fuente. El voltaje en color rojo es la primera etapa de nuestro multiplicador, en color azul tenemos la segunda etapa y en color verde la entrada de corriente alterna. 

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/4kv.png}
\caption{Multiplicador de voltaje sin carga}
\end{figure}


Para una carga con una exigencia de 1 mA podemos observar la figura 3.11. Como vemos ahora el riso y la caída en el voltaje es perceptible a simple vista.


\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/1ma.png}
\caption{Multiplicador de voltaje con 1 mA de carga}
\end{figure}

Para una carga con una exigencia de 10 mA podemos observar la figura 3.12. Tenemos una caída de voltaje bastante significativa y un riso bastante pronunciado.


\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/10ma.png}
\caption{Multiplicador de voltaje con 10 mA de carga}
\end{figure}

Tenemos un voltaje $V_{1mA}=3.9KV$, $V_{10mA}=3.2KV$ y $V_{NL}=4KV$ ahora utilizando la ecuación 2.7 podemos calcular la eficiencia de nuestra fuente y utilizar este punto de referencia para la construcción de nuestro proyecto. Para una carga de 1 mA tenemos $VR_{1mA}=2.5\%$ Y para una carga de 10 mA $VR_{10mA}=20\%$ valor limite para nuestro circuito.
\newpage

\section{Firmware}
\subsection{Interface gráfica}
Para el desarrollo de la interface gráfica se ha realizado en el ambiente de programación de Arduino, intentando la utilización de la menor cantidad de librerías de autoria no propia y siguiendo algunas reglas de programación básicas para micro-controladores como lo es la no utilización de los comando delay. Dicho código se divide en varias secciones, para el cual solo se utilizaron las siguientes librerías:

\begin{verbatim}

#include <UTFT.h>
#include <URTouch.h>

\end{verbatim}

En la siguiente figura podemos observar la topologia del firmware que se ha desarrollado.\\

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/diagramafir.png}
\caption{Multiplicador de voltaje con 10 mA de carga}
\end{figure}


El microcontrolador cuenta con múltiples salidas que permiten una comunicación con el Hardware desarrollado, se han definido las siguientes variables, salidas y entradas del micro controlador.

\begin{verbatim}

void setup(){

  myGLCD.InitLCD();
  myGLCD.clrScr();
  myTouch.InitTouch();
  myTouch.setPrecision(PREC_HI);
  Serial.begin(9600);
  Serial.setTimeout(50);
  }

//Definimos fuentes que utilizaremos
extern uint8_t SmallFont[];
extern uint8_t BigFont[];
extern uint8_t SevenSegNumFont[];

//variables que estaremos utilizando
int x,y,pantalla=1,k,voltaje=1,p=0,p1=0,p2=0,p3=0,vout=0;
char dato[20];

//variables para tomar datos de UART

String str = "";
const char separator = ',';
const int dataLength = 2;
int data[dataLength];
char vin[20];
char current[20];

\end{verbatim}

Como vemos se ha utilizado la función setTimeout, configuración de la comunicación serial, necesaria en el proyecto para mantener un enseo de datos sin riesgos a perdida de informacion debido a los subprocesos que se realizan dentro del firmware diseñado. SetTimeout() establece los milisegundos máximos para esperar los datos de transmisión, por defecto es de 1000 milisegundos. Esta función es parte de la clase Stream y es llamada por cualquier clase que hereda de ella (Wire, Serial, etc.). \cite{settime}\\


Todo el código esta dividido en funciones, las cuales llamamos en nuestro LOOP, tratando siempre de cumplir con las siguientes características: no utilización de la función delay, no utilización de ciclos que dependa de alguna condición externa, utilizar el menor código posible para una acción. Las funciones que se utilizaron para la el despliegue de información de la primera pantalla fue el siguiente:


\begin{verbatim}

 
void botones1(){ 
  myGLCD.setFont(BigFont); 
  for (x=0; x<3; x++)
  {
  
    myGLCD.setColor(0, 0, 255);
    myGLCD.fillRoundRect (200, 10+(x*55), 310, 60+(x*55));
    myGLCD.setColor(255, 255, 255);
    myGLCD.drawRoundRect (200, 10+(x*55), 310, 60+(x*55));
  }
for (x=0; x<2; x++)
  {
  
    myGLCD.setColor(0, 0, 255);
    myGLCD.fillRoundRect (10+(x*155), 175, 155+(x*155), 225);
    myGLCD.setColor(255, 255, 255);
    myGLCD.drawRoundRect (10+(x*155), 175, 155+(x*155), 225);
  }
  
  myGLCD.setBackColor(0, 0, 255);
  myGLCD.print("ON 2", 220 , 30);
  myGLCD.print("ON 3", 220 , 85);
  myGLCD.print("ON 1", 220 , 140);
  //myGLCD.print("UART ON", 185 , 195);
  myGLCD.print("V SET", 40 , 190);
  myGLCD.print("CONFIG", 190 , 190);
  }
  
void marco1(int x1, int y1, int x2, int y2){ 

  myGLCD.setColor(255, 0, 0);
  myGLCD.drawRoundRect (x1, y1, x2, y2);
  
  while (myTouch.dataAvailable())
  myTouch.read();
  myGLCD.setColor(255, 255, 255);
  myGLCD.drawRoundRect (x1, y1, x2, y2);
}
\end{verbatim}

Mediante el código anterior podemos, con ciertas variables, dibujar nuestra área de trabajo en la pantalla, obteniendo como resultado el dibujo de la figura 3.6.

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{Capitulo3/figs/pantalla1.jpg}
\caption{Pantalla 1}
\end{figure}

Mediante esta configuración de dibujo partimos para el código de configuración del TOUCH para lo que llamamos la "pantalla 1".

\begin{verbatim}
void touch1(){ 
      myTouch.read();
      x=myTouch.getX();
      y=myTouch.getY();
      if((x>=200) && (x<=310))
      {
        if((y>=10) && (y<=60)){ //boton ON 2
          marco1(200,10,310,60);
        }
        
        if((y>=65) && (y<=115)){ //boton ON 3
          marco1(200,65,310,115);
        }
        
        if((y>=120) && (y<=170)){ //boton ON 1
          marco1(200,120,310,170);
        }
      }
      
      if((y>=175) && (y<=225))
      {
        if((x>=10) && (x<=155)){ //boton V SET
        
          marco1(10,175,155,225);
          pantalla =2;
        }
      
        if((x>=165) && (x<=310)){ //boton config
        
          marco1(165,175,310,225);
        }
}
}
\end{verbatim}

Observamos que el despliegue de estas funciones solo están conformadas por elementos "if" y el llamado a funciones descritas por nosotros se despliegan de la misma manera, resaltando esto debido a que se desarrollo un código lo mas eficientemente posible en cuestión de tiempos de ejecución. \\

Dividimos el dibujo de la "pantalla 2" y las funciones para el touch de la pantalla dos en los siguientes codigos:\\

Funciones dibujo pantalla 2

\begin{verbatim}
void botones2(){
  myGLCD.setBackColor(0,0,255);
  for (x=0; x<4; x++) //botones +
  {
  
    myGLCD.setColor(0, 0, 255);
    myGLCD.fillRoundRect (10+(x*60), 10, 60+(x*60), 60);
    myGLCD.setColor(255, 255, 255);
    myGLCD.drawRoundRect (10+(x*60), 10, 60+(x*60), 60);
    myGLCD.print("+", 27+(x*60), 27);
  }
  for (x=0; x<4; x++) //botones -
  {
  
    myGLCD.setColor(0, 0, 255);
    myGLCD.fillRoundRect (10+(x*60), 170, 60+(x*60), 220);
    myGLCD.setColor(255, 255, 255);
    myGLCD.drawRoundRect (10+(x*60), 170, 60+(x*60), 220);
    myGLCD.print("-", 27+(x*60), 190);
  }

  for (x=0; x<4; x++) //blanco 
  {
  
    myGLCD.setColor(255, 255, 255);
    myGLCD.fillRoundRect (10+(x*60), 70, 60+(x*60), 160);
    myGLCD.setColor(255, 0, 0);
    myGLCD.drawRoundRect (10+(x*60), 70, 60+(x*60), 160);
  }

  myGLCD.setColor(0, 0, 255); /// boton set
   myGLCD.fillRoundRect(250,70,310,160);
   myGLCD.setColor(255, 255, 255);
   myGLCD.drawRoundRect(250,70,310,160);
   myGLCD.print("set" , 255,105);
  }
\end{verbatim}

Podemos observar el resultado del dibujo en la figura 3.14.

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{Capitulo3/figs/pantalla2.jpg}
\caption{Pantalla 2}
\end{figure}

 Funciones TOUCH pantalla 2:
\begin{verbatim}
void touch2(){
      myTouch.read();
      x=myTouch.getX();
      y=myTouch.getY();

      if((y>=10) && (y<=60)){ /////////////botones +
        if((x>=10) && (x<=60)){ //boton + kilos
        
          marco1(10,10,60,60);
          myGLCD.setFont(SevenSegNumFont); 
          suma(1,0,0,0,0,0);
        }
        if((x>=70) && (x<=120)){ //boton + centena
        
          marco1(70,10,120,60);
          suma(0,1,0,0,0,0);
        }
        if((x>=130) && (x<=180)){ //boton + decena
        
          marco1(130,10,180,60); 
          suma(0,0,1,0,0,0);
          
        }
        if((x>=190) && (x<=240)){ //boton + unidad
        
          marco1(190,10,240,60);
          suma(0,0,0,1,0,0);
        }
        }
        if((y>=170) && (y<=220)){ ////////////botones -
        if((x>=10) && (x<=60)){ //boton + kilos
        
          marco1(10,170,60,220);
          suma(1,0,0,0,0,1);
          
        }
        if((x>=70) && (x<=120)){ //boton + centena
        
          marco1(70,170,120,220);
          suma(0,1,0,0,0,1);
          
        }
        if((x>=130) && (x<=180)){ //boton + decena
        
          marco1(130,170,180,220);
          suma(0,0,1,0,0,1);
          
        }
        if((x>=190) && (x<=240)){ //boton + unidad
        
          marco1(190,170,240,220);
          suma(0,0,0,1,0,1);
        }
        }

        if((x>=250) && (x<=310)){ // boton SET

          if((y>=70) && (y<=160)){
          
            marco1(250,70,310,160);
            pantalla =1;
            
            if(vout >=0 && vout <=1000){
            
            Serial.println(vout);
            }
            }    
        }
    }
    
\end{verbatim}

Una vez que definimos las funciones a utilizar para estas dos primeras pantallas proseguimos a las funciones de cálculos y procesamiento de datos. Para ello hemos creado una función capaz de configurar el voltaje de salida, manteniendo una comunicación UART hacia un micro-controlador. 

\begin{verbatim}
void suma(int x1,int x2,int x3,int x4, int k, int w){ 

          myGLCD.setFont(SevenSegNumFont);
          myGLCD.setColor(0, 0, 0);
          myGLCD.setBackColor(255,255,255);
          int q;  
          
          if(x1 == 1){//algoritmo kilos
          
            if(w==0 && p<9){
            
            vout=vout+1000;
            p=p+1;
            q=p*x1+p1*x2+p2*x3+p3*x4;
            sprintf(dato,"%d",q)
            }
            
            if(w==1 && p>0){
            
            vout=vout-1000;
            p=p-1;
            q=p*x1+p1*x2+p2*x3+p3*x4;
            sprintf(dato,"%d",q);
              }
              
            myGLCD.print(dato,20*x1+80*x2+140*x3+200*x4,90);
          }
          
          if(x2 == 1){ //algoritmo centena
          
            if(w==0 && p1<9){
            
            vout=vout+100;
            p1=p1+1;
            q=p*x1+p1*x2+p2*x3+p3*x4;
            sprintf(dato,"%d",q);
            }
            
            if(w==1 && p1>0){
            
            vout=vout-100;
            p1=p1-1;
            q=p*x1+p1*x2+p2*x3+p3*x4;
            sprintf(dato,"%d",q);
              }
              
            myGLCD.print(dato,20*x1+80*x2+140*x3+200*x4,90);
          }
          
          if(x3 == 1){//algoritmo decenas
            if(w==0 && p2<9){
            
            vout=vout+10;
            p2=p2+1;
            q=p*x1+p1*x2+p2*x3+p3*x4;
            sprintf(dato,"%d",q);
            }
           
            if(w==1 && p2>0){
            
            vout=vout-10;
            p2=p2-1;
            q=p*x1+p1*x2+p2*x3+p3*x4;
            sprintf(dato,"%d",q);
              }
            myGLCD.print(dato,20*x1+80*x2+140*x3+200*x4,90);
            //Serial.println(vout);
            
          }
          
          if(x4 == 1){//algoritmo unidades
            if(w==0 && p3<9){
            
            vout=vout+1;
            p3=p3+1;
            q=p*x1+p1*x2+p2*x3+p3*x4;
            sprintf(dato,"%d",q);
            
            }
            if(w==1 && p3>0){
            
            vout=vout-1;
            p3=p3-1;
            q=p*x1+p1*x2+p2*x3+p3*x4;
            sprintf(dato,"%d",q);
              
              }
            myGLCD.print(dato,20*x1+80*x2+140*x3+200*x4,90);
          }
          
          if(k==1){
          
            for(x=0 ; x<4 ; x++){
            
              sprintf(dato,"%d",p);
              myGLCD.print(dato,20,90);
              sprintf(dato,"%d",p1);
              myGLCD.print(dato,80,90);
              sprintf(dato,"%d",p2);
              myGLCD.print(dato,140,90);
              sprintf(dato,"%d",p3);
              myGLCD.print(dato,200,90);
              
              }
            }
    }
\end{verbatim}

Una segunda función es la encargada de recibir los datos procedentes del segundo micro-controlador, encargado de leer los datos de sensores y preparar el funcionamiento del inversor. 

\begin{verbatim}
void vinput(){
      str = Serial.readStringUntil('\n');
      
      for (int i = 0; i < dataLength ; i++)
      {
         int index = str.indexOf(separator);
         data[i] = str.substring(0, index).toInt();
         str = str.substring(index + 1);
      }
      
      for (int i = 0; i < sizeof(data) / sizeof(data[0]); i++)    
      {
      
      Serial.print(data[i]); 
      Serial.print('\t');} 
      Serial.println();
      
                  myGLCD.setFont(BigFont);
                  sprintf(vin, "%d",data[0]);
                  sprintf(current, "%d", data[1]);
                  myGLCD.print("     " ,10,50);
                  myGLCD.print("     " ,10,70);
                  myGLCD.setBackColor(0,0,0);
                  myGLCD.setColor(255,255,255);
                  myGLCD.print(vin ,10,50);
                  myGLCD.print(current ,10,70);
  }
\end{verbatim}

Mediante las funciones anteriores podemos mantener una comunicacion INPUT y OUTPUT mediante UART, con el segundo micro-controlador, y mantener un senseo de las variables necesarias para el correcto funcionamiento de la fuente de alto voltaje. Ahora mostramos en cuerpo del programa principal, encargado del control de cada una de las funciones anteriores.

\begin{verbatim}
void loop(){
//pantalla 1
if(pantalla == 1){

    myGLCD.fillScr(VGA_BLACK);
    botones1();
    myGLCD.setFont(BigFont); 
    char set[25];
    sprintf(set, "%d",vout);
    myGLCD.setBackColor(0,0,0);
    myGLCD.print(set ,10,100);
    myGLCD.print("V set" ,100,100);
    myGLCD.print("V out" ,100,50);
    myGLCD.print("mA out" ,100,70);
    myGLCD.print(vin ,10,50);
    myGLCD.print(current ,10,70);
    
    while(true)
         {
         
        if(myTouch.dataAvailable())touch1();
        if(pantalla == 2 )break;
      	if (Serial.available()>0){vinput();}
      
            }
            }
        
//pantalla 2
if(pantalla == 2){

  myGLCD.fillScr(VGA_BLACK);
  botones2();
  suma(0,0,0,0,1,0);
  
  while(true)
    {
    
      if(myTouch.dataAvailable())touch2();
      if(pantalla == 1)break;
      
    }
    }
    }
\end{verbatim}
\newpage
\section{Implementación del Hardware}

Una vez obtenido el diseño de todas las etapas, así como también la programación del firmware se prosigue a la fabricación de los PCB de la fuente de corriente directa a 180W, el acondicionamiento de la parte digital a la etapa de potencia. Se aisló mediante una caja que solo da acceso al usuario a la parte de salidas y entradas como vemos en la imagen 3.15 Evitando así riesgos al usuario. \\


\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/noimagen.png}
\caption{Multiplicador de voltaje sin carga}
\end{figure}

Una vez terminado el Hardware se hicieron pruebas de cada modulo desarrollado, con la finalidad de indicar las condiciones optimas para el sistema en general, haciendo pruebas con diferentes cargas y observando el ruido obtenido de ellos. 

\subsection{Fuente de 180W}

Se ha terminado la maquinación de la fuente de voltaje en el router LPKF y realizado el ensamble. Se tienen 180 W que pueden ser peligrosos si no se tiene el cuidado necesario, es por ello que se ha optado de aislar el circuito y dejar solamente las salidas y entradas necesarias como podemos ver en la imagen 1.17.

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{Capitulo3/figs/fotofuente.png}
\caption{Multiplicador de voltaje sin carga}
\end{figure}

Se ha optado hacer pruebas a 12V y cargas de 7.5 OHMS, 15 OHMS y una prueba sin carga, esperando obtener el menor ruido posible. La configuración para el experimento se puede observar en la figura 3.17. Mediante estos resultados se ha echo una gráfica gaussiana para determinar el voltaje RMS en cada experimento. 



\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/sincarga.png}
\caption{Fuente 12V sin carga}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/75ohms.png}
\caption{Fuente 12V con carga a 7.5 OHMS}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/15ohms.png}
\caption{Fuente 12V con carga a 15 OHMS}
\end{figure}

Como observamos nuestro RMS se mantiene desde 0.0471v sin carga a 0.0546V con una carga de 7.5 ohms o 90w, obteniendo una regulación de voltaje de $\%VR=0.0627$ que significa una eficiencia del 99.93\% cuando la fuente es sometida a una carga resistiva de 90w, eficiencia bastante buena para los experimentos siguientes. 

\subsection{Inversor de voltaje}

Este modulo ha sido aislado de la misma manera que se aisló la fuente de 180W (figura 3.21), debido a los riesgos que conlleva si no se tiene el cuidado pertinente. Ahora implementando la fuente desarrollada se alimenta al inversor y se hace un arreglo similar al experimento anterior, analizando en el osciloscopio la salida sin carga, con cargas de 15 OHMS y de 7.5 OHMS, variando en este caso la frecuencia de salida en 60 HZ, 1 KHZ y 6 khz.



\begin{figure}[H]
\centering
\includegraphics[width=9cm]{Capitulo3/figs/fotofuente.png}
\caption{Implementacion experimento inversor.}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Capitulo3/figs/pwm1.jpg}
\caption{Implementación inversor salida con carga inductiva.}
\end{figure}

Mediante estas configuraciones se obtuvieron las mediciones que se pueden ver en las figuras XXX para cada configuración respectivamente. 

\subsection{Multiplicador de voltaje}

Existen aspectos claves para este apartado que definirán la calidad de nuestra salida, es por ello que se han realizado pruebas variando algunos aspectos como lo son la frecuencia y el ciclo de trabajo incidente en la bobina primaria del transformador de alto voltaje. Podemos observar el circuito desarrollado (figura 3.23) y mediante mediciones sin carga se observa el voltaje de salida con el osciloscopio (figura 3.24)

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{Capitulo3/figs/fotomulti.png}
\caption{Implementación inversor}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{Capitulo3/figs/fotofuente.png}
\caption{Implementación inversor}
\end{figure}
